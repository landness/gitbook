未曾设想的道路：

加入的组内的主要语言是C，参与的项目全部是用C开发的，之后主要使用的语言是C，C++可能只有开发工具和写测试用例才能用得上

C++的那些特性都用不到了 之前一直想的是精进C++的技术。。

C++17添加了string_view 类似go里面的string 保存指向字符串的字面量和size，相当与string的只读版本，优势是减少了堆拷贝

添加了更加智能的推导规则 比如pair 现在可以直接定义了,不需要显式指定类型
```
std::pair p{3,"p"}
```
添加了if初始化语句
```
// 限制了itor的作用域 更加安全 语义更明确
if(auto it = m.find(10)); it != m.end()) {return it->second; }
```
添加了std::any 代替void* std::any会保存源T类型，检查转换后的类型是否相符，更加安全，而且any析构时会析构对象

现在C++17可以这么写了
```
// 不需要声明一个不必要的中间变量了 直接使用key value
for(const auto& [key, value]: map){
  // ...
}
```

最近用C++先开发了一版存储工具，实现中没注意的一些问题导致了bug：

emplace_back(new obj) 其中obj调用了一系列对象的构造函数
最底层的bstream 静态构造 没用new 导致cache没有分配内存 而直接调用init函数中的memset 导致abort
-->静态构造不能调用构造函数 其中的成员未分配内存 
--> 约定来说，init/uninit函数用于对象的静态构造，new/free用于对象动态构造，这里显然要自动调用构造函数的话要new出来

局部变量存入容器会调用拷贝构造函数而后存放在堆区生命周期变长，
容器调用clearerase或者容器离开作用域会调用元素的析构函数，而如果元素是对象指针并不会调用析构函数，所以可以用智能指针代替指针实现自动释放

函数有返回值但忘记return了，这时候函数没报错，默认返回了函数体内申请第一块内存的地址，导致后面报错

数组或者二维数组遍历时的步长编译器会自己调整，不需要 i*sizeof(elem),多此一举

发现自己写C代码时有一些习惯性的错误，总结一下：

变量定义 即分配空间之后，要有用memset初始化的习惯，不然会出现奇奇怪怪的问题
比如判断链表是否到达末尾,如果没有初始化为null, 临界条件失效
```
while(node) {
  node = node->next;
}
```

对于堆上的变量来说，malloc可以直接用base库下zalloc，一步到位，具体来说就是
```
#define zalloc(t) (t *)malloc_and_clear(sizeof(t))

void *
malloc_and_clear(size_t size)
{
    void *ptr = malloc(size);
    if(ptr) memset(ptr,0,size);
    return prt;
}
```
对于栈上的变量，定义之后自动分配内存，需要mem_clear(&temp,sizeof(temp)),具体来说
```
#define mem_clear(ptr,0,size)
```
大致的顺序是 定义--memset-->初始化init

生命周期在本函数内就完成的变量 不要定义为堆变量

典型的就是字符串，直接用char[STRINF_SIZE_LIMIT]，不要申请string，因为string会在堆上申请小内存
之前因为用不惯C下的char*数组所以一直用 string或base库下的string_t，c下的字符串赋值操作用snprintf的变种,封装和使用如下：
```
static inline int32_t
pe_vsnprintf(char *buf, uint32_t len, const char *fmt, va_list va)
{
  int32_t rt;

  rt = vsnprintf(buf, len, fmt, va);
  if (rt <= 0 || (uint32_t)rt > len) {
    if (len) *buf = 0;
    rt = -1;
  }

  return rt;
}

static inline int32_t
pe_snprintf(char *buf, uint32_t len, const char *fmt, ...)
{
  va_list va;
  int32_t rt;

  va_start(va, fmt);
  rt = pe_vsnprintf(buf, len, fmt, va);
  va_end(va);

  return rt;
}

  char path[MAX_PATH] = { 0 };
  int32_t rt;

  rt = pe_snprintf(path, sizeof(path), "%s/%" PRIi64, fi->dir, fi->index.min_ts);
  if (rt <= 0) return -1;

```

在栈上定义指向变量的指针是不能自动申请变量内存的，而是只分配了指针的内存，要定义init

涉及内存申请的代码，都要加容错处理，增加代码的健壮性。容错处理主要是内存释放，锁释放等等，
酌情判断当前错误是否有较大影响，是否还可以继续程序，返回相应的结果

```
  index_t *i = zalloc(index_t);
  if (!i) return null;

  string_t *str = string_new();
  if(!str) goto failed;

failed:
  if(i) free(i);
  if(str) string_free(str);
  return -1；
```

创建对象前先想想能不能不创建，尽可能减少中间量

关于数组和指针的互用，《C专家编程》中讲的很清楚了
![数组和指针的互用时机](../pic/数组和指针互用时机.jpg)
数组只有在声明时才可以用{}初始化