# 1. 前言
时序数据库的数据在写到磁盘之前，需要先进行编码压缩，以减少数据占用。

时序数据的每个数据点由时间戳和值{ts,val}组成，ts为int64_t, val为float64。

- 数据特点：
对于固定时间间隔的时间点，其时间戳的delta-of-delta为0
大部分的时序数据点的值相对于其邻近点并不会有显著变化，所以相近的浮点数的符号、指数和尾数的开头几位都会是相同的

编码算法：facebook的gorilla paper encoding

# 2. bitstream
由于各种编码算法直接操作到bit，所以需要实现对字符数组bytestream的按位写，按位读能力
bitstream对象

```
struct tsdb_bstream_s
{
  uint32_t                        pos;
  /* write stream*/
  uint8_t                         cache[1024];
  uint8_t                         byte;
  uint8_t                         bit_count;
  /* read stream */
  uint8_t                         *stream;
  int32_t                          size;
  uint64_t                         buffer;
  uint8_t                          bit_valid;
  bool                             eof;
}tsdb_bstream_t;
```

按位写：char[]数组 ---> bstream

其中的核心代码是：将一个数(byte)的某一位(bit_count)置为1
**byte |= 1 << bit_count**

```
static inline void
tsdb_bstream_reset(tsdb_bstream_t *bs)
{
  memset(bs->cache, 0, 1024);
  bs->pos = 0;
  bs->bit_count = 8;
  bs->bit_valid = 0;
  bs->eof = false;
}

static inline int8_t
tsdb_bstream_append(tsdb_bstream_t *bs)
{
  if (bs->pos > 1024 - 1) return -1;

  bs->cache[bs->pos] = bs->byte;
  bs->pos++;
  
  return 0;
}

static inline int8_t
tsdb_bstream_write_bit(tsdb_bstream_t *bs, bit b)
{
  /* 写操作核心就是这句 bit_count代表byte的第几位 */
  /* 常用操作：将一个数的某一位置1 */
  if (b) 
    bs->byte |= 1 << (bs->bit_count - 1);
  }

  bs->bit_count--;
  if (bs->bit_count == 0) {
    if (tsdb_bstream_append(bs) != 0) return -1;
    bs->byte = 0;
    bs->bit_count = 8;
  }

  return 0;
}

static inline int8_t
tsdb_bstream_write_byte(tsdb_bstream_t *bs, uint8_t by)
{
  bs->byte |= by >> (8 - bs->bit_count);

  if (tsdb_bstream_append(bs) != 0) return -1;

  bs->byte = by << bs->bit_count;

  return 0;
}

static inline int8_t
tsdb_bstream_write_bits(tsdb_bstream_t *bs, uint64_t u, int nbits)
{
  uint8_t byte = 0;

  if (nbits > 64 || nbits < 0) return -1;

  u <<= (64 - nbits);

  while (nbits >= 8) {
    byte = u >> 56;
    if (tsdb_bstream_write_byte(bs, byte) != 0)
      return -1;
    u <<= 8;
    nbits -= 8;
  }

  while (nbits > 0) {
    if (tsdb_bstream_write_bit(bs, u >> 63) != 0)
      return -2;
    u <<= 1;
    nbits--;
  }

  return 0;
}

static inline int8_t
tsdb_bstream_flush(tsdb_bstream_t *bs, bit b)
{
  while (bs->bit_count != 8) {
    if (tsdb_bstream_write_bit(bs, b) != 0) return -1;
  }

  return 0;
}
```
按位读: bstream ---> char[]
```
static inline int
bits_len(uint64_t x)
{
  int n = 0;
  static const uint8_t len8_tab[256] = {
  0x00, 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
  0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
  0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
  0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  };

  if (x >= ((uint64_t)1 << 32)) {
    x >>= 32;
    n = 32;
  }

  if (x >= 1 << 16) {
    x >>= 16;
    n += 16;
  }

  if (x >= 1 << 8) {
    x >>= 8;
    n += 8;
  }

  return n + len8_tab[x];
}

static inline int
leading_zero64(uint64_t u)
{
  return 64 - bits_len(u);
}

static inline int
trailing_zero64(uint64_t u)
{
  if (u == 0) return 64;

  static const uint64_t de_bruijn64 = 0x03f79d71b4ca8b09;
  static const uint8_t de_bruijn64_tab[64] = {
    0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4,
    62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5,
    63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11,
    54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6,
  };

  return de_bruijn64_tab[(u&-u)*de_bruijn64 >> (64 - 6)];
}

static inline bool
tsdb_bstream_load_next_buffer(tsdb_bstream_t *bs, uint8_t nbits)
{
  if (bs->pos >= bs->size) return false;

  if (bs->pos + 8 < bs->size) {
    bs->buffer = (uint64_t)bs->stream[7 + bs->pos] | (uint64_t)bs->stream[6 + bs->pos] << 8
      | (uint64_t)(bs->stream[5 + bs->pos]) << 16 | (uint64_t)(bs->stream[4 + bs->pos]) << 24
      | (uint64_t)(bs->stream[3 + bs->pos]) << 32 | (uint64_t)(bs->stream[2 + bs->pos]) << 40
      | (uint64_t)(bs->stream[1 + bs->pos]) << 48 | (uint64_t)(bs->stream[0 + bs->pos]) << 56;
    bs->pos += 8;
    bs->bit_valid = 64;
    return true;
  }

  int nbytes = (int)(nbits / 8) + 1;

  if ((bs->pos + nbytes) > bs->size) {
    nbytes = bs->size - bs->pos;
  }

  uint64_t buffer = (uint64_t)0;

  for (int i = 0; i < nbytes; i++)
  {
    buffer = buffer | (uint64_t)(bs->stream[bs->pos + i])
      << (uint)(8 * (nbytes - i - 1));
  }

  bs->buffer = buffer;
  bs->pos += nbytes;
  bs->bit_valid = (uint8_t)(nbytes * 8);

  return true;
}

static inline uint64_t
tsdb_bstream_read_bits_fast(tsdb_bstream_t *bs, uint8_t nbits)
{
  if (bs->bit_valid < nbits) {
    bs->eof = true;
    return 0;
  }

  bs->bit_valid -= nbits;
  uint64_t bit_mask = (uint64_t)~0 >> (64 - nbits);

  return (bs->buffer >> bs->bit_valid) & bit_mask;
}

static inline uint64_t
tsdb_bstream_read_bits(tsdb_bstream_t *bs, uint8_t nbits)
{
  if (!bs->bit_valid) {
    if (!tsdb_bstream_load_next_buffer(bs, nbits)) {
      bs->eof = true;
      return false;
    };
  }

  if (bs->bit_valid >= nbits) {
    return tsdb_bstream_read_bits_fast(bs, nbits);
  }

  /* read all remaining valid bits from the current buffer and a part from the next one */
  uint64_t bit_mask = (uint64_t)~0 >> (64 - bs->bit_valid);
  nbits -= bs->bit_valid;
  uint64_t res = (bs->buffer & bit_mask) << nbits;
  bs->bit_valid = 0;

  if (!tsdb_bstream_load_next_buffer(bs, nbits)) {
    bs->eof = true;
    return false;
  }

  res |= ((bs->buffer >> (bs->bit_valid - nbits)) & bit_mask);
  bs->bit_valid -= nbits;

  return res;
}

static inline uint8_t
tsdb_bstream_read_byte(tsdb_bstream_t *bs)
{
  return (uint8_t)tsdb_bstream_read_bits(bs, 8);
}
```
# 3. int64：varint64编码
整型高位往往有很多0空位，varint压缩了高位的0

原理就是每个字节用最高位作为符号位，指示这个字节前是否还有非0字节

步骤1：取出字节串末7位
步骤2：在7位的最高位添加1构成一个字节，如果是最后一次取出（前面都为0），则在最高位添加0构成1个字节；
步骤3：将每个字节拼成一个字节串（这里就涉及了大小端编码）

这样解压缩时，根据标志位判断是否结束读取

https://blog.csdn.net/weixin_43954926/article/details/102869587

```
struct tsdb_encoder_s
{
  tsdb_bstream_t                 *bs;
  xc_string_t                    *file_name;
  FILE                           *fd;
  int64_t                         t0;
  int64_t                         t1;
  int64_t                         t;
  uint64_t                        delta;
  double                          value;
  uint64_t                        leading;
  uint64_t                        trailing;
  uint16_t                        read_nums;
}tsdb_encoder_t;

char*
tsdb_encoder_varint64_put(char *dst, uint64_t v)
{
  static const int B = 128;
  uint8_t *ptr = (uint8_t*)dst;

  while (v >= B) {
    *(ptr++) = v | B;
    v >>= 7;
  }

  *(ptr++) = (uint8_t)v;

  return (char*)(ptr);
}

void
tsdb_encoder_varint64(tsdb_encoder_t *enc, uint64_t v)
{
  char buf[10];

  char *ptr = tsdb_encoder_varint64_put(buf, v);

  for (int i = 0; i < ptr - buf; i++) {
    tsdb_bstream_write_byte(enc->bs, buf[i]);
  }
}

bool
tsdb_decoder_varint64(tsdb_bstream_t *bs, uint64_t *v)
{
  const char *limit = (char*)bs->stream + bs->size;

  char *p = (bs->stream + bs->pos);

  uint64_t res = 0;

  for (int shift = 0; shift <= 63 && p < limit; shift += 7) {
    uint64_t byte = *(uint8_t*)p;
    p++;
    if (byte & 128) {
      res |= ((byte & 127) << shift);
    }
    else {
      res |= (byte << shift);
      *v = res;
      bs->pos = p - (char*)bs->stream;
      return true;
    }
  }

  return false;
}
```
# 4. 时间戳：delta-of-delta编码
算法流程：
第一个时间戳用varint64编码

第二个时间戳计算delta, 并用varint64编码

接下来针对每个时间戳计算其对应的 delta-of-delta: 
如果为0, 则用一个比特存储 ‘0’
如果在[−63,64] 之间, 用 2 个比特存储 ‘10’ , 然后接下来 7 比特存储dod的具体值.
如果在[−255,256] 之间, 用 3 个比特存储 ‘110’, 然后接下来 9 比特存储dod的具体值.
如果在[−2047,2048] 之间, 用 4 个比特存储 ‘1110’, 然后接下来 12 比特存储dod的具体值.
其它情况, 用 4 个比特存储 ‘1111’, 然后接下来 32 比特存储dod的具体值.
这里range的计算是一个算是facebook的经验值，主要是为了防止数据点丢失，delta-of-delta过大，所以用了不同的range和长度去存

对于固定时间间隔上报数据来说，其deltaofdelta值为0，所以一个时间戳用一个bit就可以表示，大大提高了压缩率

```
struct tsdb_encoder_s
{
  tsdb_bstream_t                 *bs;
  xc_string_t                    *file_name;
  FILE                           *fd;
  int64_t                         t0;
  int64_t                         t1;
  int64_t                         t;
  uint64_t                        delta;
  double                          value;
  uint64_t                        leading;
  uint64_t                        trailing;
  uint16_t                        read_nums;
}tsdb_encoder_t;

void
tsdb_encoder_point(tsdb_encoder_t *enc, tsdb_field_point_t *pt)
{
  XC_DCHECK(pt);
  if (!pt) return;

  uint64_t t_delta = 0;

  if (enc->t0 == 0) {
    tsdb_encoder_varint64(enc, pt->ts);
    tsdb_bstream_write_bits(enc->bs, (uint64_t)pt->value, 64);
    enc->t0 = pt->ts;
  }
  else if (enc->t1 == 0) {
    t_delta = (uint64_t)(pt->ts - enc->t0);
    tsdb_encoder_varint64(enc, t_delta);
    tsdb_encoder_float64(enc, pt->value);
    enc->t1 = pt->ts;
  }
  else {
    t_delta = (uint64_t)(pt->ts - enc->t);

    int64_t delta_of_delta = t_delta - enc->delta;

    if (delta_of_delta == 0) {
      tsdb_bstream_write_bit(enc->bs, 0);
    }
    else if (-63 <= delta_of_delta && delta_of_delta <= 64) {
      tsdb_bstream_write_bits(enc->bs, 0x02, 2);
      tsdb_bstream_write_bits(enc->bs, (uint64_t)delta_of_delta, 7);
    }
    else if (-255 <= delta_of_delta && delta_of_delta <= 256) {
      tsdb_bstream_write_bits(enc->bs, 0x06, 3);
      tsdb_bstream_write_bits(enc->bs, (uint64_t)delta_of_delta, 9);
    }
    else if (-2047 <= delta_of_delta && delta_of_delta <= 2048) {
      tsdb_bstream_write_bits(enc->bs, 0x0e, 4);
      tsdb_bstream_write_bits(enc->bs, (uint64_t)delta_of_delta, 12);
    }
    else {
      tsdb_bstream_write_bits(enc->bs, 0x0f, 4);
      tsdb_bstream_write_bits(enc->bs, (uint64_t)delta_of_delta, 64);
    }
    tsdb_encoder_float64(enc, pt->value);
  }

  enc->t = pt->ts;
  enc->value = pt->value;
  enc->delta = t_delta;
#endif
}

tsdb_field_point_t *
tsdb_decoder_point(tsdb_encoder_t *dec)
{
  tsdb_field_point_t *dst;

  dst = xc_zalloc(tsdb_field_point_t);
  if(!dst) return xc_null;

  if (dec->read_nums == 0) {
    tsdb_decoder_varint64(dec->bs, &dec->t);

    dec->value = tsdb_bstream_read_bits(dec->bs, 64);
    dst->ts = dec->t;

    dst->value = dec->value;
    dec->read_nums++;
    return dst;
  }

  if (dec->read_nums == 1) {
    tsdb_decoder_varint64(dec->bs, &dec->delta);
    dec->t += dec->delta;

    tsdb_decoder_float64(dec);

    dst->ts = dec->t;
    dst->value = dec->value;
    dec->read_nums++;
    return dst;
  }

  /* read delta-of-delta */
  uint8_t delimiter = 0;
  for (int i = 0; i < 4; i++) {
    delimiter <<= 1;

    bit bit1 = tsdb_bstream_read_bits_fast(dec->bs, 1);
    if (dec->bs->eof) {
      bit1 = tsdb_bstream_read_bits(dec->bs, 1);
      dec->bs->eof = false;
    }
    if (!bit1) break;

    delimiter |= 1;
  }
  uint8_t sz = 0;
  int64_t delta_of_delta = 0;

  switch (delimiter) {
  case 0x00:
    break;
  case 0x02:
    sz = 7;
    break;
  case 0x06:
    sz = 9;
    break;
  case 0x0e:
    sz = 12;
    break;
  case 0x0f:
    delta_of_delta = (int64_t)tsdb_bstream_read_bits(dec->bs, 64);
    break;
  default:
    printf("unknown delimiter found\n");
    break;
  }

  if (sz != 0) {
    uint64_t bits = tsdb_bstream_read_bits_fast(dec->bs, sz);
    if (dec->bs->eof) {
      bits = tsdb_bstream_read_bits(dec->bs, sz);
      dec->bs->eof = false;
    }

    if (bits > (1 << (sz - 1))) {
      bits = bits - (1 << sz);
    }

    delta_of_delta = (int64_t)bits;
  }

  dec->delta = (uint64_t)((int64_t)dec->delta + delta_of_delta);
  dec->t += (int64_t)(dec->delta);

  tsdb_decoder_float64(dec);
  dst->ts = dec->t;
  dst->value = dec->value;

  return dst;
#endif
}
```

# 5. float64：xor编码

时序数据往往不会大幅波动，相邻的两个值相似，异或值0位会比较多，单独记录前后导0可以提高压缩率

### 5.1 浮点数 IEEE754存储方式：二进制的科学计数法
float64 = num * 2^n （num为1.xxxx）通过保存等号右边的num和n来表示一个float64

|---|----|
|符号位|指数位|尾数位|
|1位|11位|52位|

符号位 0正1负
指数位 n+1023
尾数为 nums 1.xxxx小数点后的xxxx
### 5.2 异或值xor存储方式
原理是 存前一个数与当前值的异或值，
X^X=0 ----> 0^X=X
A^B=X ---->B= A^X
第一种情况是最理想的，数据点的value值没变则只需要用一个bit存0就可以表示

对于第二种情况，存X，存储方式是这样的，将X划分为前导0，有效位，后导0，比如
X = ‭0000000001100010011100000000000000000000000000000000000000000000
前导0数量为 9 后导0数量为 44 有效位为11000100111， 就存这三个量，9，44，11000100111
|----|----|
|前导0数量|后导0数量|有效位|
|5位|6位|11000100111|

所以对于第二种情况又可以细分成两种情况
异或值X的前后导0数量都大于等于前一个数，这种情况可以引入共享位，置为1表示与前一个数共享前后导0，X按照共享位掐头去尾之后即为有效位
异或值的前后导0数量小于前一个数，则就按照上面的格式写
### 5.3 算法流程
了解完5.2的存储方式后，算法流程就是写入的值不断与前一个值取异或值X，判断异或值属于5.2种的三种情况的哪种情况，采用对应存储方式存储即可，代码实现如下：
```
struct tsdb_encoder_s
{
  tsdb_bstream_t           *bs;
  xc_string_t                    *file_name;
  FILE                           *fd;
  int64_t                         t0;
  int64_t                         t1;
  int64_t                         t;
  uint64_t                        delta;
  double                          value;
  uint64_t                        leading;
  uint64_t                        trailing;
  uint16_t                        read_nums;
}tsdb_encoder_t;

/* 编码 */
void
tsdb_encoder_float64(tsdb_encoder_t *enc, double v)
{
  uint64_t *vp, *va, vdelta;

  vp = (uint64_t*)&v;
  va = (uint64_t*)&enc->value;
  vdelta = *vp ^ *va;

  if (vdelta == 0) {
    tsdb_bstream_write_bit(enc->bs, 0);
    return;
  }

  tsdb_bstream_write_bit(enc->bs, 1);

  uint64_t leading = leading_zero64(vdelta);
  uint64_t trailing = trailing_zero64(vdelta);
  leading &= 0x1F;
  if (leading >= 32)
    leading = 31;

  if (enc->leading != ~0 && leading >= enc->leading &&
    trailing >= enc->trailing) {
    tsdb_bstream_write_bit(enc->bs, 0);
    tsdb_bstream_write_bits(enc->bs, vdelta >> enc->trailing,
      64 - enc->leading - enc->trailing);
  }
  else {
    enc->leading = leading;
    enc->trailing = trailing;

    tsdb_bstream_write_bit(enc->bs, 1);
    tsdb_bstream_write_bits(enc->bs, leading, 5);

    uint64_t sigbits = 64 - leading - trailing;
    tsdb_bstream_write_bits(enc->bs, sigbits, 6);
    tsdb_bstream_write_bits(enc->bs, vdelta >> trailing, sigbits);
  }
}

/* 解码 */
void
tsdb_decoder_float64(tsdb_encoder_t *dec)
{
  bit bit1 = tsdb_bstream_read_bits_fast(dec->bs, 1);
  if (dec->bs->eof) {
    bit1 = tsdb_bstream_read_bits(dec->bs, 1);
    dec->bs->eof = false;
  }

  if (bit1) {
    bit1 = tsdb_bstream_read_bits_fast(dec->bs, 1);
    if (dec->bs->eof) {
      bit1 = tsdb_bstream_read_bits(dec->bs, 1);
      dec->bs->eof = false;
    }

    if (bit1) {
      uint64_t bits = tsdb_bstream_read_bits_fast(dec->bs, 5);
      if (dec->bs->eof) {
        bits = tsdb_bstream_read_bits(dec->bs, 5);
        dec->bs->eof = false;
      }

      dec->leading = (uint8_t)bits;

      bits = tsdb_bstream_read_bits_fast(dec->bs, 6);
      if (dec->bs->eof) {
        bits = tsdb_bstream_read_bits(dec->bs, 6);
        dec->bs->eof = false;
      }

      uint8_t mbits = bits;
      if (!mbits) mbits = 64;
      dec->trailing = 64 - dec->leading - mbits;
    }

    uint8_t mbits = 64 - dec->leading - dec->trailing;

    uint64_t bits = tsdb_bstream_read_bits_fast(dec->bs, mbits);
    if (dec->bs->eof) {
      bits = tsdb_bstream_read_bits(dec->bs, mbits);
      dec->bs->eof = false;
    }

    int64_t *vbits = (int64_t*)&(dec->value);
    *vbits ^= bits << dec->trailing;
    dec->value = *(double*)vbits;
  }
}

```